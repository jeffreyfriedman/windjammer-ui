# Windjammer UI Compiler Integration

**How Windjammer UI code compiles to desktop and browser targets**

---

## Overview

```
.wj file (Windjammer UI code)
         |
         v
    Parser (AST)
         |
         v
   Type Checker
         |
         v
   UI Code Generator
         |
    +----+----+
    |         |
    v         v
Desktop    Browser
(Rust)     (WASM)
```

---

## Phase 1: Parsing

### Input: Windjammer UI Code

```windjammer
@component
fn Counter() -> UI {
    let count = signal(0)
    
    VStack {
        Text("Count: {count}")
        Button("Increment", on_click: || count += 1)
    }
}
```

### Output: AST

```rust
Item::Function(FunctionDecl {
    name: "Counter",
    decorators: vec![
        Decorator {
            name: "component",
            args: vec![]
        }
    ],
    return_type: Type::Named("UI"),
    body: Block {
        statements: vec![
            Statement::Let {
                name: "count",
                value: Expression::Call {
                    function: "signal",
                    args: vec![Expression::Literal(0)]
                }
            },
            Statement::Expression(
                Expression::MacroInvocation {
                    name: "VStack",
                    body: Block {
                        statements: vec![
                            Expression::Call {
                                function: "Text",
                                args: vec![
                                    Expression::StringInterpolation(...)
                                ]
                            },
                            Expression::Call {
                                function: "Button",
                                args: vec![
                                    Expression::Literal("Increment"),
                                    Expression::NamedArg {
                                        name: "on_click",
                                        value: Expression::Closure(...)
                                    }
                                ]
                            }
                        ]
                    }
                }
            )
        ]
    }
})
```

---

## Phase 2: Type Checking

### UI Type System

```windjammer
// UI is a special type representing renderable UI
type UI = VNode

// Components are functions that return UI
type Component = fn(...) -> UI

// Signals are reactive values
type Signal<T> = { get: fn() -> T, set: fn(T) -> void }

// Event handlers are closures
type EventHandler<T> = fn(T) -> void
```

### Type Checking Rules

1. **Components must return `UI`**
   ```windjammer
   @component
   fn MyComponent() -> UI { ... }  // ✅ OK
   
   @component
   fn BadComponent() -> String { ... }  // ❌ Error: must return UI
   ```

2. **Signal operations are type-safe**
   ```windjammer
   let count = signal(0)        // Signal<i32>
   count.set(10)                // ✅ OK
   count.set("hello")           // ❌ Error: expected i32, found String
   ```

3. **Props are type-checked**
   ```windjammer
   @component
   fn Greeting(name: String) -> UI { ... }
   
   Greeting(name: "Alice")      // ✅ OK
   Greeting(name: 123)          // ❌ Error: expected String, found i32
   ```

---

## Phase 3: Desktop Code Generation (Rust + egui)

### Windjammer UI Code

```windjammer
@component
fn Counter() -> UI {
    let count = signal(0)
    
    VStack {
        Text("Count: {count}")
        Button("Increment", on_click: || count += 1)
    }
}
```

### Generated Rust Code

```rust
// AUTO-GENERATED by Windjammer UI Compiler v0.1.0
// DO NOT EDIT

use eframe::egui;
use std::sync::{Arc, Mutex};

#[derive(Clone)]
struct Signal<T: Clone> {
    value: Arc<Mutex<T>>,
}

impl<T: Clone> Signal<T> {
    fn new(value: T) -> Self {
        Self {
            value: Arc::new(Mutex::new(value)),
        }
    }
    
    fn get(&self) -> T {
        self.value.lock().unwrap().clone()
    }
    
    fn set(&self, value: T) {
        *self.value.lock().unwrap() = value;
    }
}

struct CounterState {
    count: Signal<i32>,
}

impl CounterState {
    fn new() -> Self {
        Self {
            count: Signal::new(0),
        }
    }
}

fn render_counter(ctx: &egui::Context, state: &mut CounterState) {
    egui::CentralPanel::default().show(ctx, |ui| {
        ui.vertical(|ui| {
            // Text("Count: {count}")
            ui.label(format!("Count: {}", state.count.get()));
            
            // Button("Increment", on_click: || count += 1)
            if ui.button("Increment").clicked() {
                state.count.set(state.count.get() + 1);
            }
        });
    });
}

// Entry point
fn main() -> Result<(), eframe::Error> {
    let options = eframe::NativeOptions {
        initial_window_size: Some(egui::vec2(400.0, 300.0)),
        ..Default::default()
    };
    
    eframe::run_native(
        "Counter",
        options,
        Box::new(|_cc| {
            Box::new(CounterApp::new())
        }),
    )
}

struct CounterApp {
    state: CounterState,
}

impl CounterApp {
    fn new() -> Self {
        Self {
            state: CounterState::new(),
        }
    }
}

impl eframe::App for CounterApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        render_counter(ctx, &mut self.state);
    }
}
```

---

## Phase 4: Browser Code Generation (WASM)

### Windjammer UI Code

```windjammer
@component
fn Counter() -> UI {
    let count = signal(0)
    
    VStack {
        Text("Count: {count}")
        Button("Increment", on_click: || count += 1)
    }
}
```

### Generated Rust (for WASM)

```rust
// AUTO-GENERATED by Windjammer UI Compiler v0.1.0
// Compile with: wasm-pack build --target web

use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, window};
use std::rc::Rc;
use std::cell::RefCell;

#[wasm_bindgen(start)]
pub fn main() {
    console_error_panic_hook::set_once();
    
    let app = CounterApp::new();
    app.mount("app");
}

struct Signal<T: Clone> {
    value: Rc<RefCell<T>>,
    subscribers: Rc<RefCell<Vec<Box<dyn Fn()>>>>,
}

impl<T: Clone> Signal<T> {
    fn new(value: T) -> Self {
        Self {
            value: Rc::new(RefCell::new(value)),
            subscribers: Rc::new(RefCell::new(Vec::new())),
        }
    }
    
    fn get(&self) -> T {
        self.value.borrow().clone()
    }
    
    fn set(&self, value: T) {
        *self.value.borrow_mut() = value;
        self.notify();
    }
    
    fn notify(&self) {
        for subscriber in self.subscribers.borrow().iter() {
            subscriber();
        }
    }
    
    fn subscribe(&self, callback: Box<dyn Fn()>) {
        self.subscribers.borrow_mut().push(callback);
    }
}

struct CounterApp {
    count: Signal<i32>,
    root: Option<Element>,
}

impl CounterApp {
    fn new() -> Self {
        Self {
            count: Signal::new(0),
            root: None,
        }
    }
    
    fn mount(&mut self, id: &str) {
        let document = window().unwrap().document().unwrap();
        let root = document.get_element_by_id(id).unwrap();
        
        // Initial render
        self.render(&root);
        self.root = Some(root);
        
        // Subscribe to state changes
        let root_clone = self.root.as_ref().unwrap().clone();
        let count_clone = self.count.clone();
        self.count.subscribe(Box::new(move || {
            // Re-render on state change
            Self::render_static(&root_clone, &count_clone);
        }));
    }
    
    fn render(&self, root: &Element) {
        Self::render_static(root, &self.count);
    }
    
    fn render_static(root: &Element, count: &Signal<i32>) {
        let document = window().unwrap().document().unwrap();
        
        // Clear previous content
        root.set_inner_html("");
        
        // Create VStack
        let vstack = document.create_element("div").unwrap();
        vstack.set_attribute("style", "display: flex; flex-direction: column; gap: 8px;").unwrap();
        
        // Text("Count: {count}")
        let text = document.create_element("div").unwrap();
        text.set_text_content(Some(&format!("Count: {}", count.get())));
        vstack.append_child(&text).unwrap();
        
        // Button("Increment", on_click: || count += 1)
        let button = document.create_element("button").unwrap();
        button.set_text_content(Some("Increment"));
        
        let count_clone = count.clone();
        let closure = Closure::wrap(Box::new(move || {
            count_clone.set(count_clone.get() + 1);
        }) as Box<dyn FnMut()>);
        
        button
            .dyn_ref::<HtmlElement>()
            .unwrap()
            .set_onclick(Some(closure.as_ref().unchecked_ref()));
        closure.forget(); // Keep closure alive
        
        vstack.append_child(&button).unwrap();
        root.append_child(&vstack).unwrap();
    }
}
```

### Generated HTML

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Counter</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #app {
            max-width: 400px;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div id="app"></div>
    <script type="module">
        import init from './counter.js';
        await init();
    </script>
</body>
</html>
```

---

## Widget Mapping

### Windjammer UI → Desktop (egui)

| Windjammer UI | egui Equivalent |
|---------------|-----------------|
| `Text("...")` | `ui.label("...")` |
| `Button("...", on_click: ...)` | `if ui.button("...").clicked() { ... }` |
| `TextInput(value: ...)` | `ui.text_edit_singleline(&mut value)` |
| `Checkbox(checked: ...)` | `ui.checkbox(&mut checked, "...")` |
| `Slider(value: ...)` | `ui.add(egui::Slider::new(&mut value, ...))` |
| `ColorPicker(value: ...)` | `ui.color_edit_button_rgb(&mut color)` |
| `VStack { ... }` | `ui.vertical(\|ui\| { ... })` |
| `HStack { ... }` | `ui.horizontal(\|ui\| { ... })` |
| `ScrollArea { ... }` | `egui::ScrollArea::vertical().show(ui, \|ui\| { ... })` |

### Windjammer UI → Browser (DOM)

| Windjammer UI | DOM Equivalent |
|---------------|----------------|
| `Text("...")` | `<div>...</div>` |
| `Button("...", on_click: ...)` | `<button onclick="...">...</button>` |
| `TextInput(value: ...)` | `<input type="text" value="...">` |
| `Checkbox(checked: ...)` | `<input type="checkbox" checked="...">` |
| `Slider(value: ...)` | `<input type="range" value="...">` |
| `ColorPicker(value: ...)` | `<input type="color" value="...">` |
| `VStack { ... }` | `<div style="display: flex; flex-direction: column">...</div>` |
| `HStack { ... }` | `<div style="display: flex; flex-direction: row">...</div>` |
| `ScrollArea { ... }` | `<div style="overflow: auto">...</div>` |

---

## Compiler Phases Implementation

### src/compiler/ui/mod.rs

```rust
pub mod parser;       // Parse @component, UI syntax
pub mod type_checker; // Type check UI code
pub mod codegen;      // Generate Rust code
pub mod desktop;      // Desktop-specific codegen (egui)
pub mod web;          // Web-specific codegen (WASM)

pub fn compile_ui(
    source: &str,
    target: CompilationTarget,
) -> Result<GeneratedCode, CompileError> {
    // 1. Parse
    let ast = parser::parse_ui(source)?;
    
    // 2. Type check
    type_checker::check(&ast)?;
    
    // 3. Generate code based on target
    match target {
        CompilationTarget::Desktop => {
            desktop::generate_egui_code(&ast)
        }
        CompilationTarget::Web => {
            web::generate_wasm_code(&ast)
        }
    }
}
```

---

## Next Steps

1. **Implement parser for @component decorator**
2. **Add UI type to type system**
3. **Implement desktop code generator (egui backend)**
4. **Implement web code generator (WASM backend)**
5. **Test with simple counter example**
6. **Iterate based on feedback**

**Target:** Working counter example (desktop + web) by end of Phase 1

